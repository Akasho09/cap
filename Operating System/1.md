## Operating System
An Operating System is *system software* that acts as an interface between the user/applications and computer hardware.
![alt text](image.png)
- It manages all hardware resources and provides services so applications can run smoothly.
> Basically its like common code required to run applications.

## Why OS?
1. Bulky and complex app. (Hardware interaction code must be in app‚Äôs code base)
2. Resource exploitation by 1 App.
3. No memory protection.

## OS Functions :
An operating system function -
- Access to the computer hardware.
- interface between the user and the computer hardware
- Resource management (Aka, Arbitration) (memory, device, file, security, process etc)
- Hides the underlying complexity of the hardware. (Aka, Abstraction)
- facilitates execution of application programs by providing isolation and protection.

## OS goals ‚Äì
‚Ä¢ Maximum CPU utilization
‚Ä¢ Less process starvation
‚Ä¢ Higher priority job execution

## Types:
1. Single process OS :  only 1 process executes at a time from the ready queue. [Oldest]

2. Batch-processing OS:
Example:
- If multiple users submit programs written in FORTRAN, COBOL, or Assembly, they are collected, sorted, and run together as a batch to save setup and processing time.
- Example: Early IBM mainframe systems
- Used in: Payroll systems, old banking systems

3. 3Ô∏è‚É£ Multiprogramming Operating System
    - Multiple programs stay in memory
    - CPU switches(**CONTEXT SWITCHING**) when one waits for I/O
    - Improves CPU utilization
- Used in: General-purpose computers
> Max CPU utli ‚úÖ , Starvation is there ‚ùå, Higher priority maintainted(Interrupt maro n get CPU) ‚úÖ

4. 4Ô∏è‚É£ Multitasking Operating System
> - Multiprogramming + Time quantum
- One user runs multiple applications
- Can be preemptive or cooperative
- Examples:
    - Windows
    - macOS
### How Multitasking Works
- CPU executes one process for a small time slice
- Saves its state (context switching)
- Switches to another process
- Repeats very fast (milliseconds)

> Max CPU ‚úÖ , No Starvation ‚úÖ , Higher Priority maintainted ‚úÖ.

### Types of Multitasking
1. üîπ Preemptive Multitasking
- OS decides when a task stops
- Uses CPU scheduling algorithms
- More stable & secure
- Examples:
    - Windows
    - Linux
    - macOS

2. üîπ Cooperative Multitasking
- A task voluntarily gives up CPU
- If one app hangs ‚Üí whole system slows
- Example: Old Mac OS (pre-OS X)

### How is Time Quantum Decided? ‚è±Ô∏è
- The time quantum (time slice) is the maximum CPU time a process gets in Round Robin / preemptive multitasking before being preempted.
- üëâ The Operating System kernel, based on system design and workload (Not the user, not the process) decides Time Quantum 
- Typical Values (Exam-Oriented)
    - 1‚Äì10 ms ‚Üí Desktop / interactive OS
    - 10‚Äì100 ms ‚Üí Server systems
    - RTOS ‚Üí Fixed & predictable

## MultiProcessing : 
A Multiprocessing Operating System uses more than one CPU (or core) to execute multiple processes simultaneously.

### How Multiprocessing Works
- Tasks are divided among multiple CPUs
- Each CPU executes a different process at the same time
- OS handles load balancing and synchronization

> Max CPU ‚úÖ , No Starvation ‚úÖ , Higher Priority maintainted ‚úÖ.

### Types of Multiprocessing
1. 1Ô∏è‚É£ Symmetric Multiprocessing (SMP)
- All CPUs are equal
- One shared memory
- Any CPU can run any process
- Examples:
    - Linux
    - Windows
- üìå Most modern systems use SMP

2. 2Ô∏è‚É£ Asymmetric Multiprocessing (AMP)
- One master CPU controls others
- Master assigns tasks to slave CPUs
- Simpler but less flexible
- Used in:
- Embedded systems
- Old architectures

3. NUMA (Non-Uniform Memory Access) :
- Memory is divided; each processor has its own local memory for faster access.  | High-performance servers, supercomputers |

| Multiprocessing         | Multitasking     |
| ----------------------- | ---------------- |
| Multiple CPUs           | Single CPU       |
| True parallel execution | CPU time sharing |
| Higher throughput       | Faster response  |
| Hardware-dependent      | Software-based   |

## Distributed Operating System
- A Distributed Operating System manages a group of independent computers (nodes) and makes them appear to users as one single unified system.
> üëâ Multiple machines + one OS view.

### How It Works (Simple)
- Nodes are connected via a network
- OS handles:
    - Process placement
    - Inter-node communication
    - Load balancing
    - Failure recovery

### Types of Distributed OS
1. 1Ô∏è‚É£ Client‚ÄìServer Model
- Servers provide services
- Clients request services
- Example: Web applications, databases

> üëâ The Operating System works on both the client and the server, but with different roles.

2. 2Ô∏è‚É£ Peer-to-Peer (P2P) Model
- All nodes act as equals
- No central control
Used in: File sharing systems

> üëâ In P2P, the Operating System runs on every node, and each node acts as both a client and a server.

## Real Time OS (RTOS)
- A Real-Time Operating System (RTOS) is an OS designed to respond to events within a guaranteed, fixed time limit (deadline).

### Types of RTOS
1. 1Ô∏è‚É£ Hard RTOS
- Missing a deadline = system failure
- Used in safety-critical systems
- Examples:
    - VxWorks
    - QNX
- Use cases:
‚úàÔ∏è Aircraft control, üöó ABS, üè• pacemakers

2. 2Ô∏è‚É£ Soft RTOS
- Deadlines are important but occasional misses allowed
- Performance degrades, system doesn‚Äôt fail
- Examples:
    - FreeRTOS
    - RTLinux
- Use cases:
üéÆ Multimedia, üì∫ streaming, üì± telecom

## Multithreading 
- is a technique where multiple threads (lightweight units of execution) run within the same process, sharing the same memory and resources.
- üëâ Multiple threads = multiple tasks running concurrently inside one program.
- 
| Process         | Thread        |
| --------------- | ------------- |
| Heavyweight     | Lightweight   |
| Separate memory | Shared memory |
| Slow creation   | Fast creation |
| IPC required    | No IPC needed |
| More overhead   | Less overhead |

> üìå A process can have many threads, but a thread belongs to only one process.
- How Multithreading Works
- Threads share:
    - Code
    - Data
    - Heap
- Threads have their own:
    - Stack
    - Registers
    - Program counter
- ‚û°Ô∏è OS scheduler schedules threads, not just processes (in modern OS).

| Multithreading          | Multiprocessing          |
| ----------------------- | ------------------------ |
| Shared memory           | Separate memory          |
| Faster communication    | Safer (no shared memory) |
| Less overhead           | More overhead            |
| Complex synchronization | Less synchronization     |

## Components of OS
1. User Space :

2. Kernel :
- Heart of the operating system
- Runs in privileged (kernel) mode
- Functions:
    - CPU scheduling
    - Memory management
    - Process & thread management
    - Device control
- üìå Without the kernel, the OS cannot function.


## Types of Kernels:
1. Monolithic : 
> Entire OS runs in kernel space
- a. All functions are in kernel itself.
- b. Bulky in size.
- c. Memory required to run is high.
- d. Less reliable, one module crashes -> whole kernel is down.
- e. High performance as communication is fast. (Less user mode, kernel mode overheads)
- f. Eg. Linux, Unix, MS-DOS.

2. Micro Kernel
- a. Only major functions are in kernel.
    - i. Memory mgmt.
    - ii. Process mgmt.
- b. File mgmt. and IO mgmt. are in User-space.
- c. smaller in size.
- d. More Reliable
- e. More stable
- f. Performance is slow.
> ‚ùå Slower (message passing overhead)
- h. Eg. L4 Linux, Symbian OS, MINIX etc.

3. 3Ô∏è‚É£ Hybrid Kernel
- Combines monolithic + microkernel
- Some services in kernel, some in user space
- Advantages
- ‚úÖ Balance of performance & stability
- Disadvantages
- ‚ùå Complex design
- Examples
    - Windows
    - macOS

## Why macOS kernel is more monolithic than microkernel ??
- macOS uses the XNU kernel, which is often described as **hybrid**.
- But in practice, it behaves much closer to a monolithic kernel than a true microkernel.
- In macOS:
    - BSD services (file system, networking, process management) run inside kernel space
    - Many device drivers also run in kernel space
    - Communication is mostly direct function calls, not message passing
- üìå This violates core microkernel principles.

### 3Ô∏è‚É£ Why macOS is closer to Monolithic
- macOS behaves monolithic because:
1. üîπ Large Kernel Space
    - File systems
    - Networking stack
    - Process management
    - Drivers (via IOKit)
- All execute in kernel mode.

2. üîπ Performance-First Design
- Microkernels suffer from IPC[ Inter Process Communication ] overhead
- Apple optimized for:
    - Desktop performance
    - Low latency
    - Smooth UI
- ‚û°Ô∏è So services were moved into kernel space.

| Aspect          | User Mode   | Kernel Mode        |
| --------------- | ----------- | ------------------ |
| Access level    | Limited     | Full               |
| Hardware access | ‚ùå No        | ‚úÖ Yes             |
| Stability       | High        | Critical           |
| Examples        | Apps, Shell | Scheduler, Drivers |
|                 |  , Music ,  |                    |
|                 | Chrome      |                    |
| Crash impact    | App crashes | System crash       |

## How user interacts with kernel ?
- System calls.

## System calls.
| Category                    | Examples                                            | Description                                  |
| --------------------------- | --------------------------------------------------- | -------------------------------------------- |
| **Process Control**         | `fork()`, `exec()`, `exit()`, `wait()`              | Create, terminate, or manage processes       |
| **File Management**         | `open()`, `read()`, `write()`, `close()`, `lseek()` | Manage files and directories                 |
| **Device Management**       | `ioctl()`, `read()`, `write()`                      | Request or release device access             |
| **Information Maintenance** | `getpid()`, `alarm()`, `sleep()`, `gettimeofday()`  | Get or set system data                       |
| **Communication**           | `pipe()`, `shmget()`, `send()`, `recv()`            | Facilitate inter-process communication (IPC) |


## System Call Interface (SCI)
> üëâ It is the bridge between user mode and kernel mode.
```yml
User Program
   ‚Üì  (system call)
System Call Interface
   ‚Üì  (mode switch)
Kernel (executes request)
   ‚Üì
Result returned to User Program
```
- EXAMPLE
    - in user mode , we write code in code editor.
    - to save we pass it via SCI .
    - SCI determines where to save and compile it in kernel mode .

## How Operating System Boots up?
- Booting is the process of starting a computer and loading the operating system into the main memory (RAM) from storage.

‚öôÔ∏è Steps of OS Booting
1. Power-On & POST (Power-On Self-Test)
- When you press the power button:
    - The power supply turns on the CPU, memory, and peripherals.
    - The BIOS/UEFI firmware runs the POST to check hardware like RAM, CPU, keyboard, etc.
- If a problem is found ‚Üí error beep codes or messages.

2. BIOS/UEFI Initialization
- BIOS/UEFI is firmware stored on a chip on the motherboard.
- It initializes hardware and sets up a minimal environment.
- Locates the bootable device (HDD, SSD, USB).

3. Bootloader Execution
- BIOS/UEFI loads the bootloader from the boot sector of the boot device.
- Common bootloaders: GRUB (Linux), Windows Boot Manager.
- The bootloader is a small program that loads the OS kernel into memory.

4. Loading the OS Kernel
- The kernel (core part of OS) is loaded into RAM.
- Kernel initializes:
    - Memory management
    - Process scheduler
    - Device drivers
    - File system

5. Initial System Processes
- The kernel starts the first system process:
    - Linux ‚Üí init or systemd
    - Windows ‚Üí smss.exe, wininit.exe
- This process starts other system services, background processes, and prepares the system for user interaction.  
```bash
Power ON
   ‚Üì
POST (Power-On Self-Test)
   ‚Üì
BIOS / UEFI Initialization
   ‚Üì
Bootloader Loads OS Kernel
   ‚Üì
Kernel Initialization
   ‚Üì
Start System Processes (init/systemd)
   ‚Üì
Load User Interface (GUI/CLI)
```

