## Virtual Memory?
- Virtual Memory is a memory management technique that allows a computer to run programs larger than the available physical RAM by using disk space as an extension of RAM.
> Virtual Memory = RAM + part of Hard Disk(c/d SWAP SPACE) (as backup memory)

### üß© Why Virtual Memory is Needed
- Physical RAM is limited
- Programs today are very large
- Allows more programs to run simultaneously
- Prevents system from crashing when RAM is full

### ‚öôÔ∏è How Virtual Memory Works
- Program requests memory
- OS loads only required parts of program into RAM
- Remaining parts stay on disk (swap space)
- When needed, data is:
    - Loaded into RAM ‚Üí Page In
    - Removed from RAM ‚Üí Page Out
- üìå This process is called Demand Paging

## üß† Key Concepts
1. üîπ Page
- A fixed-size block of memory (e.g., 4KB)

2. üîπ Page Table
- Maps virtual address ‚Üí physical address

3. üîπ Page Fault
- Occurs when required page is not in RAM and must be loaded from disk

## Locality of Reference 
- is a principle that states that a program tends to access the same memory locations repeatedly or access memory locations that are close to each other within a short period of time.

### üß© Types of Locality of Reference
1. 1Ô∏è‚É£ Temporal Locality
- üëâ If a memory location is accessed once, it is likely to be accessed again soon.

2. 2Ô∏è‚É£ Spatial Locality
- üëâ If a memory location is accessed, nearby locations are likely to be accessed soon.

3. 3Ô∏è‚É£ Sequential Locality
- üëâ Instructions are executed sequentially in memory.
- üìò Example:
Executing program line-by-line.

## ‚úÖ Pure Demand Paging
- Pure Demand Paging is a memory management technique in which no pages of a process are loaded into memory initially.
- Pages are loaded only when they are actually referenced (demanded) during execution.
- Not even a single page is loaded in advance.

### ‚öôÔ∏è How Pure Demand Paging Works
- Program starts execution with zero pages in RAM
- First instruction causes a page fault
- OS loads required page from disk into memory
- Execution continues
- Every new page reference causes another page fault until needed pages are loaded

### üß† Key Characteristics
- No preloading of pages
- Every page enters memory only when demanded
- Relies heavily on page fault handling
- Uses secondary storage (disk) as backup

### ‚öñÔ∏è Advantages
- ‚úî Very efficient memory usage
- ‚úî Reduces unnecessary memory allocation
- ‚úî Suitable for large programs

### ‚ùå Disadvantages
- ‚úñ High number of page faults at beginning
- ‚úñ Slower execution initially
- ‚úñ Can cause thrashing if memory is too small

| Feature              | Demand Paging        | Pure Demand Paging |
| -------------------- | -------------------- | ------------------ |
| Initial page loading | Some pages preloaded | No pages preloaded |
| Page fault frequency | Lower                | Higher initially   |
| Memory usage         | Moderate             | Minimal            |

### Solution :
- locality of Refrence .

## üîÅ Page Replacement Algorithms
- When main memory (RAM) is full and a new page needs to be loaded, the OS must remove (replace) one of the existing pages to make space.
- The rule used to choose which page to remove is called a Page Replacement Algorithm.

1. 1Ô∏è‚É£ FIFO (First-In First-Out)
- üìå Removes the oldest page in memory.
- Working:
    - Page that entered memory first is replaced first.
- Advantages:
    - Simple to implement
- Disadvantages:
    - May remove frequently used pages
    - Suffers from Belady‚Äôs Anomaly : 
- üß† Example:
- Pages: 1 2 3 4 (frames = 3)
‚Üí Page 1 removed first

### üîπ What is Belady‚Äôs Anomaly?
- Belady‚Äôs Anomaly is a phenomenon in page replacement algorithms where increasing the number of page frames results in more page faults ‚Äî which is counter-intuitive.
- üëâ Normally, we expect more memory ‚áí fewer page faults
- ‚ùå But in some algorithms, the opposite happens.

- üß† Where Does It Occur?
- Belady‚Äôs anomaly occurs in non-stack algorithms, mainly:
- ‚úÖ FIFO (First-In First-Out)
- ‚ùå Does NOT occur in:
    - LRU (Least Recently Used)
    - Optimal Page Replacement
#### üìå Example of Belady‚Äôs Anomaly
- Reference string:
1 2 3 4 1 2 5 1 2 3 4 5
- Frames = 3	Page Faults FIFO	9
- Frames = 4	Page Faults FIFO	10 ‚ùó
- ‚û° Increasing frames increased page faults ‚Üí Belady‚Äôs Anomaly

#### üîç Why Does This Happen?
- FIFO removes the oldest page, not the least useful one.
- Adding more frames can change the eviction order, causing more faults.
- MORE FRAME SIZE => MORE PAGE FAULTS INITILAYY WHEN ADDING PAGE IN FRAMES .

2. 3Ô∏è‚É£ Optimal Page Replacement
    - üìå Replaces the page that will not be used for the longest time in the future.
- Advantages:
    - Best possible performance
    - Minimum page faults
- Disadvantages:
    - Not implementable (future knowledge required)
- üëâ Used only for theoretical comparison

3. 2Ô∏è‚É£ LRU (Least Recently Used)
- üìå Replaces the page not used for the longest time.
- Working:
    - Tracks recent usage of pages
- Advantages:
    - Good performance
    - Approximates optimal behavior
- Disadvantages:
    - Expensive to implement (needs tracking).
> can be implemented using int for each page number and incremneting it if hit occours and removing smallest if miss.
> or using map and linkedlist in leetcode prob.

4. 4Ô∏è‚É£ LFU (Least Frequently Used)
- üìå Removes the page used least number of times
- Disadvantage:
    - Old pages with high past usage may stay forever


## Thrashing
- Thrashing is a condition in an operating system where the CPU spends most of its time swapping pages in and out of memory instead of executing processes.
> System keeps paging but does no useful work.

### ‚öôÔ∏è How Thrashing Occurs
- Thrashing happens when:
    - Too many processes are loaded into memory
    - Each process has insufficient frames
    - Continuous page faults occur
    - CPU waits for memory instead of executing.

### The cycle works like this:
- High degree of multiprogramming: Too many processes are loaded into memory.
- Lack of frames: Each process gets fewer frames than needed.
- Page replacement policy: Frequent replacements increase page faults.
> This repeated cycle of low CPU utilization ‚Üí more processes ‚Üí more page faults is called Thrashing.

### CPU Utilization
   |
   |          _______
   |         /       \
   |        /         \       ‚Üê Thrashing zone
   |______ /           \
   +----------------------------> Degree of Multiprogramming

### ‚ö†Ô∏è Causes of Thrashing
- Insufficient physical memory
- High degree of multiprogramming
- Poor page replacement algorithm
- Improper working set size

### üß† Effects of Thrashing
- Very slow system performance
- High disk I/O activity
- Low CPU utilization
- System becomes almost unresponsive

## solution
1. 1Ô∏è‚É£ Working Set Model  :   uses Locality of Refrence , LINE 30
- Ensures each process gets enough pages
- Keeps active pages in memory

2. 2Ô∏è‚É£ Page Fault Frequency (PFF)
- Monitors page fault rate
- Adds or removes frames dynamically

