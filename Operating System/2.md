## 1Ô∏è‚É£ Program
- A program is a passive set of instructions
- Stored on disk (HDD/SSD)
- Not executing
- üìå Example:
    - a.out
    - node index.js
    - chrome.exe
- üëâ Program = static code

## 2Ô∏è‚É£ Process
- A process is a program in execution
    - Active entity
    - Has its own memory and resources
- üìå When you run a program ‚Üí it becomes a process
- Each process has:
    - Process ID (PID)
    - Program counter
    - Registers
    - Stack & Heap
    - Address space
    - Open files
- üëâ Process = running instance of a program

### Basic Process States (5-State Model)
1. 1Ô∏è‚É£ New
- Process is being created
- PCB (Process Control Block) is allocated
- Not yet ready to run
> Processes are in **JOB QUEUE**
- üìå Example: Program just started

2. 2Ô∏è‚É£ Ready
- Process is loaded in memory
- Waiting for CPU time
- All resources available except CPU
- LTS (Long term Scheduler) moves the process from New->Ready.
> Processes are in **Ready QUEUE**
- üìå Stored in Ready Queue

3. 3Ô∏è‚É£ Running
- Process is currently executing on CPU
- Only one process per CPU/core can be running at a time
- STS (Short term Scheduler[üìå Uses scheduling algorithms like: FCFS , SJF , Priority , Round Robin]) selects the process from Ready .
- Dispatcher allocates the CPU to the process.
- üìå Can be preempted by scheduler

4. 4Ô∏è‚É£ Waiting / Blocked
- Process is waiting for an event or I/O
- CPU is not required right now
- Medium-Term Scheduler (MTS) suspends and resuems processes 
> Processes are in **Blocked QUEUE**
- üìå Example:
    - Waiting for disk read
    - Waiting for user input

5. 5Ô∏è‚É£ Terminated (Exit)
- Process has finished execution
- OS releases all resources
- PCB is deleted
![alt text](image-1.png)

> üìå Scheduler decides who, dispatcher does how

## Why Windows Doesn‚Äôt Need LTS
1. 1Ô∏è‚É£ Demand Paging Replaces LTS
- Windows loads only required pages into RAM
- Full program is not loaded at once
- üìå Memory admission is dynamic, not pre-decided.

## Degree of Multiprogramming (OS Goal 4)
The degree of multiprogramming is the number of processes that are present in main memory (RAM) at the same time.
> üëâ It indicates how many programs the OS can keep ready to run.
- Intent is to make ready queue a mix of CPU Bound and IO Bound processes.

| Multiprogramming             | Multiprocessing     |
| ---------------------------- | ------------------- |
| Multiple processes in memory | Multiple CPUs/cores |
| Time sharing                 | Parallel execution  |
| Software concept             | Hardware concept    |

> More processes in memory ‚Üí better CPU usage (until memory becomes a bottleneck).

## What is Swap Space?
üëâ When RAM is full, the OS moves inactive pages/processes to swap space to free RAM for active ones.
### How Swap Space Works
1. Swap Out
- Inactive pages/processes moved from RAM ‚Üí disk (swap space)
2. Swap In
- Required pages moved back from disk ‚Üí RAM

## 3Ô∏è‚É£ Thread
- A thread is the smallest unit of execution
- Exists inside a process
- Multiple threads can exist in one process
- Threads share:
    - Code
    - Data
    - Heap
    - Open files
- Threads have their own:
    - Stack
    - Registers
    - Program counter
- üëâ Thread = execution path inside a process

| Feature        | Program | Process  | Thread |
| -------------- | ------- | -------- | ------ |
| Nature         | Passive | Active   | Active |
| Stored on disk | ‚úÖ       | ‚ùå        | ‚ùå      |
| Execution      | ‚ùå       | ‚úÖ        | ‚úÖ      |
| Memory         | ‚ùå       | Separate | Shared |
| Overhead       | None    | High     | Low    |

## How does an Operating System create a Process?
- A process is created when the OS turns a program (static code) into a running instance with its own resources.
### Step-by-Step Process Creation
1. 1Ô∏è‚É£ Program Invocation
./a.out
node app.js
2. 2Ô∏è‚É£ System Call to Kernel
- The request enters kernel mode via a system call.
- Common calls:
- fork() ‚Äì create a new process (copy)
- exec() ‚Äì replace process image with a new program
- üìå In practice, many OSs use fork ‚Üí exec.
3. 3Ô∏è‚É£ Create Process Control Block (PCB)
- OS creates a PCB containing:
    - PID (Process ID)
    - Process state (new/ready)
    - Program counter & registers
    - Scheduling info (priority)
    - Open files
    - Memory pointers
- üëâ PCB = identity card of the process
4. 4Ô∏è‚É£ Allocate Memory
- OS allocates an address space:
    - Code (text)
    - Data
    - Heap
    - Stack
- Sets up virtual memory mappings.
5. 5Ô∏è‚É£ Load Program into Memory
- Program code is loaded from disk
- Libraries are linked (statically/dynamically)
- Program counter set to entry point (main)
6. 7Ô∏è‚É£ Add to Ready Queue
- Process state ‚Üí Ready
- Waiting for CPU
7. 8Ô∏è‚É£ CPU Scheduling
- Scheduler selects the process
- Context switch happens
- Process state ‚Üí Running
> ‚úÖ Process starts executing!

## Process Architecture :
High Address
+------------------+
|      Stack       |
|        ‚Üì         |
+------------------+
|      Heap        |
|        ‚Üë         |
+------------------+
|      Data        |
+------------------+
|      Code        |
+------------------+
Low Address

1. Text / Code Segment
- Compiled instructions
2. Data Segment
- Global & static variables
3. Heap
- Dynamic memory allocation (malloc, new)
- Shared by all threads in the process
4. Stack
- Function calls
- Local variables
- Return addresses
- Each thread has its own stack

## TYPES OF PROCESS 
1. Orphan Process : 
- An orphan process is a child process whose parent process has terminated, while the child is still running.
> üëâ Parent dies first ‚Üí child becomes orphan.

### How an Orphan Process is Created
- Parent process creates a child (fork)
- Parent terminates before the child
- Child continues execution
- OS reassigns the child to a system parent

### Who Adopts Orphan Processes?
- On UNIX-like systems (e.g., Linux):
- Orphans are adopted by init (PID 1) or systemd
- The OS ensures:
    - Child is monitored
    - Resources are cleaned when it exits
- üìå This prevents resource leaks.


2. Zombie Process :
- A zombie process is a child process that has finished execution, but still has an entry in the process table because its parent has not collected its exit status.
> üëâ Child is dead, parent is alive.

### How a Zombie Process is Created
- Parent creates a child (fork)
- Child finishes execution (exit)
- Parent does not call wait() / waitpid()
- OS keeps child‚Äôs PID & exit status
> ‚û°Ô∏è Child becomes a zombie for that time till parent doesnt call wait.

## SCHEDULING ALFORITHMS :
### Classification of Scheduling Algorithms
1. üîπ Non-Preemptive
- Once CPU is allocated, process runs till completion or I/O wait
- Simple but poor responsiveness

2. üîπ Preemptive
- CPU can be taken away by OS
- Better responsiveness, more complex

| **Metric**  | **Full Form**           | **Formula**                         | **Meaning (1-line)**            |
| ----------- | ----------------------- | ----------------------------------- | ------------------------------- |
| **AT**      | Arrival Time            | Given                               | Time when process enters system |
| **BT**      | Burst Time              | Given                               | CPU time required               |
| **CT**      | Completion Time         | From Gantt chart                    | Time when process finishes      |
| **TAT**     | Turnaround Time         | **CT ‚àí AT**                         | Total time in system            |
| **WT**      | Waiting Time            | **TAT ‚àí BT**<br>or **CT ‚àí AT ‚àí BT** | Time waiting in ready queue     |
| **RT**      | Response Time           | **First CPU Start ‚àí AT**            | Time till first CPU response    |
| **Avg WT**  | Average Waiting Time    | Œ£WT / n                             | Mean waiting time               |
| **Avg TAT** | Average Turnaround Time | Œ£TAT / n                            | Mean turnaround time            |
| **Avg RT**  | Average Response Time   | Œ£RT / n                             | Mean response time              |

### 
1. 1Ô∏è‚É£ First Come First Serve (FCFS)
- Type: Non-preemptive
- How it works
    - Processes executed in order of arrival
- Advantages
    - ‚úÖ Simple
    - ‚úÖ No starvation
- Disadvantages
    - ‚ùå Convoy effect : Convoy Effect is a situation in CPU scheduling where many short processes wait behind one long CPU-bound process, causing poor CPU utilization and high waiting time. 
    - ‚ùå Poor average waiting time
- üìå Used in: Batch systems (rare today)

2. 2Ô∏è‚É£ Shortest Job First (SJF)
- Type: Non-preemptive
- How it works
    - Process with smallest CPU burst executes first
- Advantages
- ‚úÖ Minimum average waiting time (optimal)
- Disadvantages
    - ‚ùå Burst time prediction needed
    - ‚ùå Starvation possible

3. 3Ô∏è‚É£ Shortest Remaining Time First (SRTF)
- Type: Preemptive version of SJF
- How it works
    - Process with least remaining time runs
    - New shorter job can preempt running process
- Advantages
- ‚úÖ Best response time
- Disadvantages
    - ‚ùå High overhead
    - ‚ùå Starvation
